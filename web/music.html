<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1024, height=768">
    <title>Arc Scroll Interface</title>
    <style>
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            position: relative;
            user-select: none;
            box-sizing: border-box;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .item {
            position: absolute;
            width: 200px;
            height: 64px;
            opacity: 0.4;
            transform: scale(0.9);
            will-change: transform, opacity, top, right;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .item.selected {
            opacity: 1;
            transform: scale(1);
        }

        .item-name {
            position: absolute;
            right: 80px;
            top: 50%;
            transform: translateY(-50%);
            color: #ffffff;
            font-size: 14px;
            text-align: right;
            white-space: nowrap;
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .item.selected .item-name {
            right: 88px;
            font-size: 16px;
            font-weight: 600;
            opacity: 1;
        }

        .item-image {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            object-fit: cover;
            transition: all 0.3s ease;
        }

        .item.selected .item-image {
            width: 64px;
            height: 64px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.7);
        }

        /* Base positions for items */
        .pos-0 { 
            right: 8%; 
            top: 5%;
            transform: scale(0.8);
        }
        .pos-1 { 
            right: 12%; 
            top: 15%;
            transform: scale(0.8);
        }
        .pos-2 { 
            right: 17%; 
            top: 25%;
            transform: scale(0.9);
        }
        .pos-3 { 
            right: 20%; 
            top: 35%;
            transform: scale(1.1);
        }
        .pos-4 { 
            right: 21%; 
            top: 50%;
            transform: scale(1.6);
        }
        .pos-5 { 
            right: 20%; 
            top: 65%;
            transform: scale(1.1);
        }
        .pos-6 { 
            right: 17%; 
            top: 75%;
            transform: scale(0.9);
        }
        .pos-7 { 
            right: 12%; 
            top: 85%;
            transform: scale(0.8);
        }
        .pos-8 { 
            right: 8%; 
            top: 95%;
            transform: scale(0.8);
        }

        /* Moving positions - will be applied via JavaScript */
        .moving {
            transition: all 0.1s linear;
        }
    </style>
</head>
<body>
    <div id="arc-guide"></div>
    <div id="container"></div>
    <div id="scroll-hint">Scroll or use ↑↓ to navigate</div>

    <script>
        // Constants for smooth scrolling
        const MOVE_STEPS = 3; // Set to 2 for 50% movement (1/2 = 0.5 or 50%)
        const MOVE = 1 / MOVE_STEPS; // How far to move in each step
        
        // Position definitions for interpolation
        const POSITIONS = {
            0: { right: 8, top: 5, scale: 0.8 },
            1: { right: 12, top: 15, scale: 0.8 },
            2: { right: 17, top: 25, scale: 0.9 },
            3: { right: 20, top: 35, scale: 1.1 },
            4: { right: 21, top: 50, scale: 1.6 },
            5: { right: 20, top: 65, scale: 1.1 },
            6: { right: 17, top: 75, scale: 0.9 },
            7: { right: 12, top: 85, scale: 0.8 },
            8: { right: 8, top: 95, scale: 0.8 }
        };
        
        // Load playlist data from playlists_with_tracks.json
        let items = [];
        let currentIndex = 0;
        let isScrolling = false;
        let currentMove = 0; // Current move progress (0 to 1)
        const container = document.getElementById('container');

        // State management for playlist/songs view
        let viewMode = 'playlists'; // 'playlists' or 'songs'
        let selectedPlaylist = null;
        let playlistData = []; // Store full playlist data with tracks
        let savedPlaylistIndex = 0; // Remember position when viewing songs

        // Load playlists from JSON file
        async function loadPlaylists() {
            try {
                const response = await fetch('../playlists_with_tracks.json');
                playlistData = await response.json();
                
                // Convert playlist data to our items format (playlists only initially)
                items = playlistData.map((playlist, index) => ({
                    id: playlist.id,
                    name: playlist.name || `Playlist ${index + 1}`, // Handle empty names
                    image: playlist.image || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSIjMzMzMzMzIi8+Cjx0ZXh0IHg9IjMyIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjI0IiBmaWxsPSIjZmZmZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj7imqo8L3RleHQ+Cjwvc3ZnPgo=' // Local SVG placeholder
                }));
                
                // Initial render
                render();
            } catch (error) {
                console.error('Error loading playlists:', error);
                // Fallback to dummy data if loading fails
                items = [
                    { id: 'fallback-1', name: 'Error Loading Playlists', image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSIjZmYwMDAwIi8+Cjx0ZXh0IHg9IjMyIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjI0IiBmaWxsPSIjZmZmZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj4hPC90ZXh0Pgo8L3N2Zz4K' }
                ];
                render();
            }
        }

        function enterPlaylistView() {
            if (viewMode !== 'playlists' || !playlistData[currentIndex]) return;
            
            // Save current playlist position
            savedPlaylistIndex = currentIndex;
            selectedPlaylist = playlistData[currentIndex];
            
            // Animate current playlist 200px left
            const selectedElement = document.querySelector('.item.selected');
            if (selectedElement) {
                selectedElement.style.transform = 'translateX(-200px) scale(1)';
                selectedElement.style.transition = 'transform 0.3s ease';
            }
            
            // Load songs after animation
            setTimeout(() => {
                loadPlaylistSongs();
            }, 300);
        }

        function loadPlaylistSongs() {
            if (!selectedPlaylist || !selectedPlaylist.tracks) {
                console.error('No tracks found for playlist');
                return;
            }
            
            // Convert tracks to items format
            items = selectedPlaylist.tracks.map(track => ({
                id: track.id,
                name: `${track.artist} - ${track.name}`,
                image: track.image || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSIjMzMzMzMzIi8+Cjx0ZXh0IHg9IjMyIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjI0IiBmaWxsPSIjZmZmZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj7imqo8L3RleHQ+Cjwvc3ZnPgo='
            }));
            
            viewMode = 'songs';
            currentIndex = 0;
            render();
        }

        function exitPlaylistView() {
            if (viewMode !== 'songs') return;
            
            // Restore playlist items
            items = playlistData.map((playlist, index) => ({
                id: playlist.id,
                name: playlist.name || `Playlist ${index + 1}`,
                image: playlist.image || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSIjMzMzMzMzIi8+Cjx0ZXh0IHg9IjMyIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjI0IiBmaWxsPSIjZmZmZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj7imqo8L3RleHQ+Cjwvc3ZnPgo='
            }));
            
            viewMode = 'playlists';
            currentIndex = savedPlaylistIndex; // Return to exact same position
            selectedPlaylist = null;
            render();
        }

        function getVisibleItems() {
            const visibleItems = [];
            const totalItems = items.length;
            
            if (totalItems === 0) return visibleItems;
            
            const centerPos = 4; // pos-4 is always the selected center
            
            // Calculate how many items we can show before and after current
            const itemsBefore = Math.min(currentIndex, centerPos);
            const itemsAfter = Math.min(totalItems - currentIndex - 1, centerPos);
            
            // Create visible items, always putting currentIndex at center when possible
            const startIndex = currentIndex - itemsBefore;
            const endIndex = currentIndex + itemsAfter;
            
            for (let i = startIndex; i <= endIndex; i++) {
                const relativePos = i - currentIndex; // -4 to +4 relative to current
                const position = centerPos + relativePos; // Convert to 0-8 position
                visibleItems.push({ item: items[i], position });
            }
            
            return visibleItems;
        }

        function render() {
            if (items.length === 0) return; // Don't render if no items loaded yet
            
            container.innerHTML = '';
            const visibleItems = getVisibleItems();
            
            visibleItems.forEach(({ item, position }) => {
                const itemEl = document.createElement('div');
                itemEl.className = `item pos-${position}`;
                
                // The selected item is always at position 4
                if (position === 4) {
                    itemEl.classList.add('selected');
                }
                
                const nameEl = document.createElement('div');
                nameEl.className = 'item-name';
                nameEl.textContent = item.name;
                
                const imgEl = document.createElement('img');
                imgEl.className = 'item-image';
                imgEl.src = item.image;
                imgEl.loading = 'lazy';
                
                itemEl.appendChild(nameEl);
                itemEl.appendChild(imgEl);
                container.appendChild(itemEl);
            });
            
            // Update debug info to show current mode
            const modeText = viewMode === 'playlists' ? 'Playlists' : `Songs: ${selectedPlaylist.name}`;
        }

        function scroll(direction) {
            if (isScrolling || items.length === 0) return;
            
            isScrolling = true;
            const oldIndex = currentIndex;
            
            // Calculate new move progress
            currentMove += MOVE * direction;
            
            // If we've completed a full move, update the index
            if (Math.abs(currentMove) >= 1) {
                // Prevent scrolling beyond boundaries
                if (direction > 0 && currentIndex < items.length - 1) {
                    currentIndex++;
                } else if (direction < 0 && currentIndex > 0) {
                    currentIndex--;
                }
                currentMove = 0; // Reset move progress
            }
            
            // Apply the move to all items
            const itemElements = document.querySelectorAll('.item');
            itemElements.forEach(item => {
                const currentPos = parseInt(item.className.match(/pos-(\d+)/)[1]);
                const nextPos = direction > 0 ? currentPos - 1 : currentPos + 1;
                
                if (nextPos >= 0 && nextPos <= 8) {
                    // Get positions from our POSITIONS object
                    const currentPosData = POSITIONS[currentPos];
                    const nextPosData = POSITIONS[nextPos];
                    
                    // Calculate intermediate position
                    const moveProgress = Math.abs(currentMove);
                    const right = interpolate(currentPosData.right, nextPosData.right, moveProgress);
                    const top = interpolate(currentPosData.top, nextPosData.top, moveProgress);
                    const scale = interpolate(currentPosData.scale, nextPosData.scale, moveProgress);
                    
                    // Apply the intermediate position
                    item.style.right = `${right}%`;
                    item.style.top = `${top}%`;
                    item.style.transform = `scale(${scale})`;
                    item.classList.add('moving');
                }
            });
            
            // Only render if the index actually changed
            if (oldIndex !== currentIndex) {
                requestAnimationFrame(render);
            }
            
            setTimeout(() => {
                isScrolling = false;
            }, 28);
        }

        // Helper function to interpolate between two values
        function interpolate(start, end, progress) {
            return start + (end - start) * progress;
        }

        // Keyboard support
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                scroll(-1);
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                scroll(1);
            }
        });

        // Load playlists when page loads
        loadPlaylists();

        // Hide scroll hint after first interaction
        let interacted = false;
        ['keydown'].forEach(event => {
            window.addEventListener(event, () => {
                if (!interacted) {
                    interacted = true;
                    document.getElementById('scroll-hint').style.display = 'none';
                }
            }, { once: true });
        });
    </script>
     <script>
        // WebSocket connection for navigation wheel events
        let ws = null;
        let lastClickTime = 0;
        const CLICK_THROTTLE_MS = 27; // Max 5 times per second (1000ms / 5 = 200ms)
        
        function connectWebSocket() {
            try {
                ws = new WebSocket('ws://localhost:8765');
                
                const timeout = setTimeout(() => {
                    if (ws.readyState === WebSocket.CONNECTING) {
                        ws.close();
                        ws = null;
                    }
                }, 2000); // 2 second timeout
                
                ws.onopen = () => {
                    clearTimeout(timeout);
                    console.log('Main server WebSocket connected');
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                ws.onclose = () => {
                    clearTimeout(timeout);
                    ws = null;
                    // Only attempt to reconnect if we had a successful connection before
                    if (ws !== null) {
                        setTimeout(() => connectWebSocket(), 5000);
                    }
                };
                
                ws.onerror = () => {
                    clearTimeout(timeout);
                    ws = null;
                    // Silently fail - main server not available (standalone mode)
                };
            } catch (error) {
                ws = null;
                // Silently fail - main server not available (standalone mode)
            }
        }
        
        function handleWebSocketMessage(data) {
            // Log all received WebSocket messages
            console.log('Received WebSocket message:', data);
            
            // Handle button messages for playlist selection and back navigation
            if (data.type === 'button' && data.data && data.data.button) {
                const button = data.data.button;
                
                if (button === 'left' && viewMode === 'playlists') {
                    // Select playlist to show songs
                    enterPlaylistView();
                    return;
                } else if (button === 'right' && viewMode === 'songs') {
                    // Go back to playlists
                    exitPlaylistView();
                    return;
                } else if (button === 'go') {
                    // Send webhook with appropriate ID
                    sendGoWebhook();
                    return;
                }
            }
            
            // Listen for navigation wheel events (not volume or laser)
            if (data.type === 'nav' && data.data) {
                const direction = data.data.direction; // 'clock' or 'counter'
                
                // Find the scrollable container
                const container = document.getElementById('container');
                if (!container) return;
                
                // Check boundaries before scrolling or clicking
                const atTop = currentIndex === 0;
                const atBottom = currentIndex === items.length - 1;
                const scrollingUp = direction === 'counter';
                const scrollingDown = direction === 'clock';
                
                // Don't scroll or click if at boundaries
                if ((atTop && scrollingUp) || (atBottom && scrollingDown)) {
                    console.log('At boundary - not scrolling or clicking');
                    return;
                }
                
                // Scroll the container content
                if (scrollingDown) {
                    // Scroll down
                    scroll(1);
                } else if (scrollingUp) {
                    // Scroll up
                    scroll(-1);
                }
                
                // Send click command back to server (rate limited)
                sendClickCommand();
            }
        }
        
        function sendClickCommand() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            try {
                const now = Date.now();
                
                // Rate limiting: only send if at least 27ms have passed since last send
                if (now - lastClickTime < CLICK_THROTTLE_MS) {
                    return;
                }
                
                lastClickTime = now;
                
                const message = {
                    type: 'command',
                    command: 'click',
                    params: {}
                };
                
                ws.send(JSON.stringify(message));
                console.log('Sent click command to server');
            } catch (error) {
                // Silently fail if sending fails
            }
        }
        
        async function sendGoWebhook() {
            if (items.length === 0) return;
            
            let id;
            
            // Get appropriate ID based on current mode
            if (viewMode === 'playlists') {
                // Send playlist ID
                const currentPlaylist = playlistData[currentIndex];
                if (!currentPlaylist) return;
                id = "spotify:playlist:" + currentPlaylist.id;
                console.log('Sending webhook for playlist:', currentPlaylist.name, 'ID:', id);
            } else if (viewMode === 'songs') {
                // Send song ID
                const currentSong = selectedPlaylist.tracks[currentIndex];
                if (!currentSong) return;
                id = "spotify:track:" + currentSong.id;
                console.log('Sending webhook for song:', currentSong.name, 'ID:', id);
            } else {
                return;
            }
            
            // Send webhook to Home Assistant
            try {
                const webhookData = {
                    device_type: "Panel",
                    button: "go",
                    panel_context: "music",
                    id: id
                };
                
                const response = await fetch('http://homeassistant.local:8123/api/webhook/beosound5c', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(webhookData)
                });
                
                if (response.ok) {
                    console.log('Webhook sent successfully:', webhookData);
                } else {
                    console.error('Webhook failed with status:', response.status);
                }
            } catch (error) {
                console.error('Error sending webhook:', error);
            }
        }
        
        // Initialize WebSocket connection when page loads
        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
        });
    </script>
</body>
</html>