<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BeoSound 5 Dashboard</title>
  <style>
    html, body { margin:0; padding:0; width:1024px; height:768px; overflow:hidden; background:#000; }
    #main-ui { display:flex; width:1024px; height:768px; }
    /* Sidebar */
    #nav { width:8%; min-width:80px; background:#1c1c1c; position:relative;
      transition: transform 0.3s ease;
    }
    #nav.hidden { transform: translateX(-100%); }
    #nav ul { list-style:none; margin:0; padding:20px 0; }
    #nav li { padding:12px; color:#fff; }
    #nav li.active { background:rgba(255,255,255,0.2); border-radius:4px; }
    #laser-pointer { position:absolute; width:4px; height:24px; background:cyan; left:0; transition: top 0.1s; }
    /* Content area */
    #content-area { flex:1; position:relative; overflow:hidden; }
    #artwork-container, #page-container {
      position:absolute; top:0; left:0; right:0; bottom:0;
      display:flex; align-items:center; justify-content:center;
      transition: opacity 0.5s ease;
    }
    #artwork-container { z-index:1; opacity:1; }
    #page-container { z-index:2; opacity:0; pointer-events:none; }
    #artwork { max-width:90%; max-height:90%; border-radius:8px; transition: opacity 0.6s ease; position:absolute; }
    #info-box { position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.7); color:#fff; padding:8px 16px; border-radius:8px;
      font-family:sans-serif; text-align:center; z-index:3;
    }
    #info-box #track-title { font-size:24px; margin-bottom:4px; }
    #info-box #track-album { font-size:16px; margin-bottom:2px; }
    #info-box #track-artist { font-size:14px; opacity:0.9; }
    /* Volume gauge: larger, more right */
    #vol-gauge { position:absolute; right:40px; top:50%; transform:translateY(-50%);
      width:200px; height:300px; z-index:3;
    }
    /* WS log */
    #ws-log { position:absolute; top:0; right:0; background:red; color:white;
      font-family:monospace; font-size:0.8em; padding:4px; width:300px; height:60px;
      overflow:hidden; z-index:10;
    }
    #playlist-container { 
      display: none; 
      color: white; 
      font-family: sans-serif; 
      text-align: center; 
      padding: 20px; 
    }
    #playlist { 
      list-style-type: none; 
      padding: 0; 
      margin: 0; 
      height: 100%; 
      overflow-y: auto; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      transform: perspective(500px) rotateY(-15deg); 
    }
    #playlist li { 
      font-size: 16px; 
      color: white; 
      transition: transform 0.3s ease, font-size 0.3s ease, color 0.3s ease; 
    }
    #playlist li.selected { 
      font-size: 24px; 
      color: cyan; 
    }
  </style>
</head>
<body>
  <div id="main-ui">
    <nav id="nav">
      <div id="laser-pointer"></div>
      <ul>
        <li>Playing now</li>
        <li>Playlists</li>
	      <li>Scenes</li>
        <li>Security</li>
        <li>Control</li>
        <li>Settings</li>
        <li>Doorcam</li>
        <li>Home status</li>
      </ul>
    </nav>
    <div id="content-area">
      <div id="artwork-container">
        <img id="artwork" src="" alt="Art" />
        <div id="info-box">
          <div id="track-title">—</div>
          <div id="track-album">—</div>
          <div id="track-artist">—</div>
        </div>
      </div>
      <div id="page-container">
        <span id="page-title" style="color:white; font-size:48px;"></span>
        <div id="playlist-container">
          <ul id="playlist">
            <!-- Playlist items will be dynamically populated -->
          </ul>
        </div>
      </div>
      <canvas id="vol-gauge" width="200" height="300"></canvas>
      <div id="ws-log"></div>
    </div>
  </div>

  <script>
    // Elements
    const nav = document.getElementById('nav');
    const navItems = [...nav.querySelectorAll('li')];
    const pointer = document.getElementById('laser-pointer');
    const artCont = document.getElementById('artwork-container');
    const pageCont= document.getElementById('page-container');
    const pageTitle= document.getElementById('page-title');
    const artwork = document.getElementById('artwork');
    const titleEl = document.getElementById('track-title');
    const albumEl = document.getElementById('track-album');
    const artistEl= document.getElementById('track-artist');
    const wsLog   = document.getElementById('ws-log');
    const vg      = document.getElementById('vol-gauge');
    const ctx     = vg.getContext('2d');
    const playlistContainer = document.getElementById('playlist-container');
    const playlist = document.getElementById('playlist');

    // Create a cached Home Assistant iframe to reuse
    let haIframe = null;
    
    // Virtual cursor for iframe navigation
    let virtualCursor = null;
    let cursorVisible = false;
    let cursorSpeed = 10; // Pixels to move per arrow key press
    let currentElements = [];
    let selectedElementIndex = -1;
    let highlightBorder = null; // Element for highlighting cards
    
    // Search and navigation state
    let haInterfaceState = 'normal'; // States: 'normal', 'search-pending', 'search-results'
    let searchResultElements = [];
    let searchResultIndex = -1;

    // Track current volume level
    let currentVolume = 0;

    // Logging function
    const recent = [];
    function logMsg(m) { 
      recent.unshift(m); 
      if(recent.length > 3) recent.pop(); 
      wsLog.innerText = recent.join('\n'); 
    }

    // HA config
    const HA_URL = 'http://homeassistant.local:8123';
    const HA_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjMDY0NDFjNDRjOWM0YTQ3ODk1OWVmMjcwYzY2MTU2ZiIsImlhdCI6MTc0NTI2ODYzNywiZXhwIjoyMDYwNjI4NjM3fQ.ldZPYpESQgL_dQj026faUhBzqTgJBVH4oYSrXtWzfC0';
    const ENTITY = 'media_player.medierum';

    // Function to create and initialize the virtual cursor
    function initVirtualCursor() {
      // Create cursor element if it doesn't exist
      if (!virtualCursor) {
        virtualCursor = document.createElement('div');
        virtualCursor.style.position = 'absolute';
        virtualCursor.style.width = '20px';
        virtualCursor.style.height = '20px';
        virtualCursor.style.borderRadius = '50%';
        virtualCursor.style.backgroundColor = 'rgba(0, 255, 255, 0.5)';
        virtualCursor.style.border = '2px solid cyan';
        virtualCursor.style.zIndex = '10000';
        virtualCursor.style.pointerEvents = 'none'; // Don't interfere with real mouse events
        virtualCursor.style.transition = 'all 0.1s ease';
        virtualCursor.style.display = 'none';
        document.body.appendChild(virtualCursor);
      }
    }

    // Function to toggle cursor visibility
    function toggleVirtualCursor() {
      cursorVisible = !cursorVisible;
      virtualCursor.style.display = cursorVisible ? 'block' : 'none';
      
      // Position cursor in the middle of the iframe if becoming visible
      if (cursorVisible && haIframe) {
        const rect = haIframe.getBoundingClientRect();
        virtualCursor.style.left = (rect.left + rect.width / 2) + 'px';
        virtualCursor.style.top = (rect.top + rect.height / 2) + 'px';
        scanElementsInIframe();
      }
    }

    // Function to move the cursor
    function moveCursor(direction) {
      if (!cursorVisible || !virtualCursor) return;
      
      const rect = virtualCursor.getBoundingClientRect();
      let left = rect.left;
      let top = rect.top;
      
      switch (direction) {
        case 'up': top -= cursorSpeed; break;
        case 'down': top += cursorSpeed; break;
        case 'left': left -= cursorSpeed; break;
        case 'right': left += cursorSpeed; break;
      }
      
      // Keep cursor within iframe bounds
      const iframeRect = haIframe.getBoundingClientRect();
      left = Math.max(iframeRect.left, Math.min(left, iframeRect.right - rect.width));
      top = Math.max(iframeRect.top, Math.min(top, iframeRect.bottom - rect.height));
      
      virtualCursor.style.left = left + 'px';
      virtualCursor.style.top = top + 'px';
    }

    // Function to scan for clickable elements in the iframe
    function scanElementsInIframe() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Clear previous elements
        currentElements = [];
        selectedElementIndex = -1;
        
        // Find all potentially interactive elements
        const interactiveSelectors = 'a, button, input, select, [role="button"], [tabindex]';
        const elements = haIframe.contentDocument.querySelectorAll(interactiveSelectors);
        
        elements.forEach(element => {
          // Check if element is visible
          const rect = element.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            currentElements.push({
              element: element,
              rect: rect
            });
          }
        });
        
        logMsg(`Found ${currentElements.length} interactive elements`);
      } catch (e) {
        logMsg('Error scanning iframe: ' + e.message);
      }
    }

    // Function to highlight the next or previous element
    function navigateElements(direction) {
      if (!cursorVisible || currentElements.length === 0) return;
      
      if (direction === 'next') {
        selectedElementIndex = (selectedElementIndex + 1) % currentElements.length;
      } else {
        selectedElementIndex = (selectedElementIndex - 1 + currentElements.length) % currentElements.length;
      }
      
      highlightSelectedElement();
    }

    // Function to highlight the selected element
    function highlightSelectedElement() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        const item = currentElements[selectedElementIndex];
        const rect = item.rect;
        
        // Position cursor over the element
        virtualCursor.style.left = (rect.left + rect.width / 2) + 'px';
        virtualCursor.style.top = (rect.top + rect.height / 2) + 'px';
        
        // Highlight effect
        virtualCursor.style.transform = 'scale(1.5)';
        setTimeout(() => {
          virtualCursor.style.transform = 'scale(1)';
        }, 200);
      }
    }

    // Function to "click" the currently selected element
    function clickSelectedElement() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        try {
          const element = currentElements[selectedElementIndex].element;
          element.click();
          
          // Visual feedback
          virtualCursor.style.backgroundColor = 'rgba(255, 255, 0, 0.8)';
          setTimeout(() => {
            virtualCursor.style.backgroundColor = 'rgba(0, 255, 255, 0.5)';
            // Rescan elements after click, as the DOM might have changed
            setTimeout(scanElementsInIframe, 500);
          }, 200);
          
          logMsg('Clicked element: ' + element.tagName);
        } catch (e) {
          logMsg('Error clicking: ' + e.message);
        }
      }
    }

    // Setup keyboard control for the virtual cursor
    document.addEventListener('keydown', (e) => {
      // Only handle keys when on Home status page
      if (navItems[curIdx].textContent !== 'Home status' && navItems[curIdx].textContent !== 'Doorcam') return;
      
      switch (e.key) {
        case 'Tab':
          if (!cursorVisible) {
            toggleVirtualCursor();
          }
          navigateElements(e.shiftKey ? 'prev' : 'next');
          e.preventDefault();
          break;
        case 'Enter':
        case ' ': // Space
          if (cursorVisible) {
            clickSelectedElement();
            e.preventDefault();
          }
          break;
        case 'Escape':
          if (cursorVisible) {
            toggleVirtualCursor();
            e.preventDefault();
          }
          break;
        case 'ArrowUp':
          if (cursorVisible) {
            moveCursor('up');
            e.preventDefault();
          }
          break;
        case 'ArrowDown':
          if (cursorVisible) {
            moveCursor('down');
            e.preventDefault();
          }
          break;
        case 'ArrowLeft':
          if (cursorVisible) {
            moveCursor('left');
            e.preventDefault();
          }
          break;
        case 'ArrowRight':
          if (cursorVisible) {
            moveCursor('right');
            e.preventDefault();
          }
          break;
      }
    });

    // Function to create highlight border for cards
    function initHighlightBorder() {
      if (!highlightBorder) {
        highlightBorder = document.createElement('div');
        highlightBorder.style.position = 'absolute';
        highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
        highlightBorder.style.borderRadius = '4px';
        highlightBorder.style.zIndex = '10000';
        highlightBorder.style.pointerEvents = 'none';
        highlightBorder.style.transition = 'all 0.2s ease';
        highlightBorder.style.display = 'none';
        document.body.appendChild(highlightBorder);
      }
    }

    // Function to toggle card navigation mode
    function toggleCardNavigation() {
      if (!highlightBorder) initHighlightBorder();
      
      cursorVisible = !cursorVisible;
      highlightBorder.style.display = cursorVisible ? 'block' : 'none';
      
      if (cursorVisible) {
        scanCardsInIframe();
        if (currentElements.length > 0) {
          selectedElementIndex = 0;
          highlightSelectedCard();
        }
      }
    }

    // Function to scan for cards in the iframe
    function scanCardsInIframe() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Clear previous elements
        currentElements = [];
        selectedElementIndex = -1;
        
        // Find all card elements in Home Assistant
        const cardElements = haIframe.contentDocument.querySelectorAll('hui-card, ha-card');
        
        cardElements.forEach(element => {
          // Check if element is visible
          const rect = element.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            currentElements.push({
              element: element,
              rect: rect
            });
          }
        });
        
        logMsg(`Found ${currentElements.length} cards`);
      } catch (e) {
        logMsg('Error scanning iframe: ' + e.message);
      }
    }

    // Function to navigate between cards
    function navigateCards(direction) {
      if (!cursorVisible || currentElements.length === 0) return;
      
      if (direction === 'right') {
        selectedElementIndex = (selectedElementIndex + 1) % currentElements.length;
      } else {
        selectedElementIndex = (selectedElementIndex - 1 + currentElements.length) % currentElements.length;
      }
      
      highlightSelectedCard();
    }

    // Function to highlight the selected card
    function highlightSelectedCard() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        const item = currentElements[selectedElementIndex];
        const rect = item.rect;
        
        // Convert iframe-relative position to document position
        const iframeRect = haIframe.getBoundingClientRect();
        const absoluteLeft = rect.left + iframeRect.left;
        const absoluteTop = rect.top + iframeRect.top;
        
        // Position highlight over the card with a slight expansion
        highlightBorder.style.left = (absoluteLeft - 5) + 'px';
        highlightBorder.style.top = (absoluteTop - 5) + 'px';
        highlightBorder.style.width = (rect.width + 6) + 'px';
        highlightBorder.style.height = (rect.height + 6) + 'px';
        
        // Pulse effect for visibility
        highlightBorder.style.boxShadow = '0 0 20px 5px rgba(255, 255, 0, 0.9)';
        setTimeout(() => {
          highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
        }, 200);
        
        // Scroll into view if needed
        item.element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    // Function to click the currently selected card
    function clickSelectedCard() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        try {
          const element = currentElements[selectedElementIndex].element;
          element.click();
          
          // Visual feedback
          highlightBorder.style.boxShadow = '0 0 25px 8px rgba(255, 255, 0, 1)';
          setTimeout(() => {
            highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
            // Rescan cards after click, as the DOM might have changed
            setTimeout(scanCardsInIframe, 500);
          }, 200);
          
          logMsg('Clicked card: ' + element.tagName);
        } catch (e) {
          logMsg('Error clicking: ' + e.message);
        }
      }
    }

    // Setup keyboard control for card navigation
    document.addEventListener('keydown', (e) => {
      // Only handle keys when on Home status page
      if (navItems[curIdx].textContent !== 'Home status' && navItems[curIdx].textContent !== 'Doorcam') return;
      
      switch (e.key) {
        case 'c': // 'c' key to toggle card navigation
          toggleCardNavigation();
          e.preventDefault();
          break;
        case 'Enter': // Enter to click
          if (cursorVisible) {
            clickSelectedCard();
            e.preventDefault();
          }
          break;
        case 'Escape': // Escape to exit
          if (cursorVisible) {
            toggleCardNavigation();
            e.preventDefault();
          }
          break;
        case 'ArrowLeft': // Left arrow for previous card
          if (cursorVisible) {
            navigateCards('left');
            e.preventDefault();
          }
          break;
        case 'ArrowRight': // Right arrow for next card
          if (cursorVisible) {
            navigateCards('right');
            e.preventDefault();
          }
          break;
      }
    });

    // WebSocket
    let ws;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 20;
    const INITIAL_RECONNECT_DELAY = 1000; // 1 second

    function connectWebSocket() {
      ws = new WebSocket('ws://localhost:8765');
      
      ws.onopen = () => {
        logMsg('WS open');
        reconnectAttempts = 0; // Reset attempts on successful connection
      };
      
      ws.onclose = () => {
        logMsg('WS close');
        attemptReconnect();
      };
      
      ws.onerror = e => {
        logMsg('WS err');
        attemptReconnect();
      };
      
      ws.onmessage = ev => {
        const {type,data} = JSON.parse(ev.data); logMsg(`${type}:${JSON.stringify(data)}`);
        if(type==='button'){
          if (navItems[curIdx].textContent === 'Home status' || navItems[curIdx].textContent === 'Doorcam') {
            if (haInterfaceState === 'search-results') {
              // For search results navigation
              if(data.button==='left') navigateSearchResults('up');
              else if(data.button==='right') navigateSearchResults('down');
              else if(data.button==='go') onGo();
            } else if (cursorVisible) {
              // For card navigation
              if(data.button==='left') navigateCards('left');
              else if(data.button==='right') navigateCards('right');
              else if(data.button==='go') onGo();
            } else {
              // Normal mode
              if(data.button==='go') onGo();
              else if(data.button==='left') prevTrack();
              else if(data.button==='right') nextTrack();
            }
          } else {
            // Original behavior for other pages
            if(data.button==='left') prevTrack();
            else if(data.button==='right') nextTrack();
            else if(data.button==='go') onGo();
          }
        }
        if(type==='laser') onLaser(data.position);
        if(type==='playback') fetchMedia();
        if(type==='volume') {
          logMsg(`Volume message received: speed=${data.speed}, direction=${data.direction || 'none'}`);
          adjustVolume(data.speed, data.direction);
        }
        if(type==='nav') {
          if (navItems[curIdx].textContent === 'Home status' || navItems[curIdx].textContent === 'Doorcam') {
            if (haInterfaceState === 'search-results') {
              // For search results navigation
              if (data.direction === 'clock') {
                navigateSearchResults('down');
              } else {
                navigateSearchResults('up');
              }
            } else if (cursorVisible) {
              // For card navigation
              if (data.direction === 'clock') {
                navigateCards('right');
              } else {
                navigateCards('left');
              }
            } else {
              handleNav(data);
            }
          } else {
            handleNav(data);
          }
        }
      };
    }

    function handleNav(data) {
      const { direction, speed } = data;
      
      // If on Doorcam or Home status page, scroll the container
      if (navItems[curIdx].textContent === 'Doorcam' || navItems[curIdx].textContent === 'Home status') {
        const scrollContainer = pageCont.querySelector('.iframe-scroll-container');
        if (scrollContainer) {
          // Amount to scroll
          const scrollAmount = 100; // pixels to scroll
          if (direction === 'clock') {
            // Scroll down
            scrollContainer.scrollTop += scrollAmount;
            logMsg('Scrolling down');
            
            // Show the scroll indicator briefly for feedback
            const instructionDiv = pageCont.querySelector('div[style*="bottom: 20px"]');
            if (instructionDiv) {
              instructionDiv.style.opacity = '1';
              instructionDiv.textContent = 'Scrolling down...';
              setTimeout(() => {
                instructionDiv.style.opacity = '0';
              }, 1000);
            }
          } else {
            // Scroll up
            scrollContainer.scrollTop -= scrollAmount;
            logMsg('Scrolling up');
            
            // Show the scroll indicator briefly for feedback
            const instructionDiv = pageCont.querySelector('div[style*="bottom: 20px"]');
            if (instructionDiv) {
              instructionDiv.style.opacity = '1';
              instructionDiv.textContent = 'Scrolling up...';
              setTimeout(() => {
                instructionDiv.style.opacity = '0';
              }, 1000);
            }
          }
          return;
        }
      }
      
      // Original playlist navigation behavior
      let currentIndex = playlistItems.findIndex(item => item.classList.contains('selected'));
      if (currentIndex === -1) currentIndex = 0;

      if (direction === 'clock') {
        currentIndex = Math.min(currentIndex + 1, playlistItems.length - 1);
      } else {
        currentIndex = Math.max(currentIndex - 1, 0);
      }

      playlistItems.forEach((item, index) => {
        item.classList.toggle('selected', index === currentIndex);
        item.style.fontSize = index === currentIndex ? '24px' : '16px';
        item.style.color = index === currentIndex ? 'cyan' : 'white';
      });

      // Scroll to the selected item
      const selectedItem = playlistItems[currentIndex];
      selectedItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    function attemptReconnect() {
      if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        logMsg('Max reconnection attempts reached');
        return;
      }

      const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);
      reconnectAttempts++;
      
      logMsg(`Attempting to reconnect in ${delay/1000} seconds...`);
      
      setTimeout(() => {
        logMsg(`Reconnection attempt ${reconnectAttempts}`);
        connectWebSocket();
      }, delay);
    }

    // Initial connection
    connectWebSocket();

    // function to adjust Sonos volume
    async function adjustVolume(speed, direction) {
      try {
        logMsg(`Current volume: ${Math.round(currentVolume * 100)}%, speed: ${speed}`);
        
        // Determine adjustment factor based on speed and direction
        let adjustment;
          // If speed isn't a number but we have direction, use direction
          adjustment = direction === 'clock' ? 0.05 : -0.05;
          logMsg(`Using direction value: adjustment = ${adjustment}`);
        
        let newVolume = currentVolume + adjustment;
        
        // Keep volume within 0-1 range
        newVolume = Math.max(0, Math.min(1, newVolume));
        logMsg(`Adjusting volume from ${Math.round(currentVolume * 100)}% to ${Math.round(newVolume * 100)}%`);
        
        // Only update if there's an actual change
        if (newVolume !== currentVolume) {
          // Update Sonos volume via Home Assistant API
          logMsg(`Sending volume_set API call to ${HA_URL} for entity ${ENTITY}`);
          try {
            const response = await fetch(`${HA_URL}/api/services/media_player/volume_set`, {
              method: 'POST',
              headers: {
                'Authorization': 'Bearer ' + HA_TOKEN,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                entity_id: ENTITY,
                volume_level: newVolume
              })
            });
            
            const responseStatus = response.status;
            logMsg(`Volume API response status: ${responseStatus}`);
            
            if (responseStatus >= 200 && responseStatus < 300) {
              // Success - update local volume immediately for responsiveness
              currentVolume = newVolume;
              logMsg(`Volume set successfully to ${Math.round(newVolume * 100)}%`);
            } else {
              const responseText = await response.text();
              logMsg(`Volume API error: ${responseStatus}, ${responseText.substring(0, 50)}...`);
            }
          } catch (apiError) {
            logMsg(`Volume API fetch error: ${apiError.message}`);
          }
          
          // Fetch latest state to sync with actual volume
          setTimeout(fetchMedia, 500);
        } else {
          logMsg('No volume change needed (already at limit)');
        }
      } catch (e) {
        logMsg(`Volume error: ${e.message}`);
        console.error('Volume adjustment error:', e);
      }
    }

    // fetch media + volume
    async function fetchMedia(){
      try{
        logMsg(`Fetching media state from ${HA_URL}/api/states/${ENTITY}`);
        const r=await fetch(`${HA_URL}/api/states/${ENTITY}`,{headers:{'Authorization':'Bearer '+HA_TOKEN}});
        const d=await r.json();
        const pic=HA_URL+d.attributes.entity_picture;
        
        // Store current volume for use with the volume wheel
        const prevVolume = currentVolume;
        currentVolume = d.attributes.volume_level || 0;
        
        if (prevVolume !== currentVolume) {
          logMsg(`Volume updated from fetch: ${Math.round(currentVolume * 100)}%`);
        }
        
        // Log all relevant media info for debugging
        logMsg(`Media state: ${d.state}, volume: ${Math.round(currentVolume * 100)}%`);
        
        // update metadata
        titleEl.textContent=d.attributes.media_title||'—';
        albumEl.textContent=d.attributes.media_album_name||'—';
        artistEl.textContent=d.attributes.media_artist||'—';
        // update artwork with crossfade
        if(artwork.src !== pic) {
          artwork.style.opacity = 0;
          artwork.addEventListener('transitionend', function once() {
            artwork.removeEventListener('transitionend', once);
            artwork.src = pic;
            artwork.style.opacity = 1;
          });
        }
      } catch(e) { 
        logMsg(`Media fetch error: ${e.message}`);
        console.warn(e); 
      }
    }
    fetchMedia(); setInterval(fetchMedia,5000);

    // nav activation
    let curIdx=0;
    function activate(i){ if(i<0)i=0; if(i>=navItems.length)i=navItems.length-1; curIdx=i;
      navItems.forEach((li,j)=>li.classList.toggle('active',j===i));
      const nr=nav.getBoundingClientRect(), ir=navItems[i].getBoundingClientRect();
      pointer.style.top=(ir.top-nr.top+4)+'px';
      
      // Handle page display based on selected item
      const page = navItems[curIdx].textContent;
      
      // Save iframe from being destroyed when navigating away from Home status
      if (pageCont.querySelector('iframe') && page !== 'Home status' && page !== 'Doorcam') {
        if (!haIframe) {
          haIframe = pageCont.querySelector('iframe');
        }
        pageCont.innerHTML = '';
        // Restore the pageTitle and playlist container elements
        if (!pageCont.contains(pageTitle)) {
          pageCont.appendChild(pageTitle);
        }
        if (!pageCont.contains(playlistContainer)) {
          pageCont.appendChild(playlistContainer);
        }
        
        // Hide navigation highlight when leaving Home status page
        if (cursorVisible && highlightBorder) {
          cursorVisible = false;
          highlightBorder.style.display = 'none';
        }
      }
      
      if (page === 'Playing now') {
        pageTitle.style.display = 'block';
        fadeToArtwork();
      } else if (page === 'Playlists') {
        pageTitle.style.display = 'none';
        playlistContainer.style.display = 'block';
        artCont.style.opacity = 0;
        pageCont.style.opacity = 1;
        pageCont.style.pointerEvents = 'auto';
        playlistItems.forEach((item, index) => {
          item.style.fontSize = '16px';
          item.style.color = 'white';
        });
      } else if (page === 'Doorcam') {
        // Disable card navigation and scanning features for this page
        if (cursorVisible && highlightBorder) {
          cursorVisible = false;
          highlightBorder.style.display = 'none';
        }
        
        pageTitle.style.display = 'none';
        playlistContainer.style.display = 'none';
        artCont.style.opacity = 0;
        pageCont.style.opacity = 1;
        pageCont.style.pointerEvents = 'auto';
        
        pageCont.innerHTML = '';
        
        // Create wrapper div for iframe and controls
        const wrapperDiv = document.createElement('div');
        wrapperDiv.style.width = '100%';
        wrapperDiv.style.height = '100%';
        wrapperDiv.style.position = 'relative';
        
        // Add scrolling instruction
        const instructionDiv = document.createElement('div');
        instructionDiv.style.position = 'absolute';
        instructionDiv.style.bottom = '20px';
        instructionDiv.style.left = '50%';
        instructionDiv.style.transform = 'translateX(-50%)';
        instructionDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
        instructionDiv.style.color = 'white';
        instructionDiv.style.padding = '10px';
        instructionDiv.style.borderRadius = '5px';
        instructionDiv.style.zIndex = '1000';
        instructionDiv.textContent = 'Use wheel to scroll up/down';
        instructionDiv.style.opacity = '1';
        instructionDiv.style.transition = 'opacity 0.5s';
        
        // Fade out instruction after 3 seconds
        setTimeout(() => {
          instructionDiv.style.opacity = '0';
        }, 3000);
        
        // Create a scrollable container
        const scrollContainer = document.createElement('div');
        scrollContainer.style.width = '100%';
        scrollContainer.style.height = '100%';
        scrollContainer.style.overflow = 'auto';
        scrollContainer.className = 'iframe-scroll-container';
        
        // Create a new iframe for the security dashboard
        const doorcamIframe = document.createElement('iframe');
        doorcamIframe.src = 'http://homeassistant.local:8123/dashboard-security/0';
        doorcamIframe.style.width = '100%';
        doorcamIframe.style.height = '200%'; // Make taller to allow scrolling
        doorcamIframe.style.border = 'none';
        doorcamIframe.style.pointerEvents = 'none'; // Prevent direct interaction with iframe
        
        // Scroll buttons
        const scrollUpButton = document.createElement('button');
        scrollUpButton.textContent = '▲';
        scrollUpButton.style.position = 'absolute';
        scrollUpButton.style.right = '20px';
        scrollUpButton.style.top = '20px';
        scrollUpButton.style.zIndex = '1000';
        scrollUpButton.style.padding = '10px 15px';
        scrollUpButton.style.backgroundColor = 'rgba(0,0,0,0.5)';
        scrollUpButton.style.color = 'white';
        scrollUpButton.style.border = 'none';
        scrollUpButton.style.borderRadius = '5px';
        scrollUpButton.style.cursor = 'pointer';
        
        const scrollDownButton = document.createElement('button');
        scrollDownButton.textContent = '▼';
        scrollDownButton.style.position = 'absolute';
        scrollDownButton.style.right = '20px';
        scrollDownButton.style.top = '70px';
        scrollDownButton.style.zIndex = '1000';
        scrollDownButton.style.padding = '10px 15px';
        scrollDownButton.style.backgroundColor = 'rgba(0,0,0,0.5)';
        scrollDownButton.style.color = 'white';
        scrollDownButton.style.border = 'none';
        scrollDownButton.style.borderRadius = '5px';
        scrollDownButton.style.cursor = 'pointer';
        
        // Add click handlers
        scrollUpButton.addEventListener('click', () => {
          scrollContainer.scrollTop -= 100;
        });
        
        scrollDownButton.addEventListener('click', () => {
          scrollContainer.scrollTop += 100;
        });
        
        // Append elements
        scrollContainer.appendChild(doorcamIframe);
        wrapperDiv.appendChild(scrollContainer);
        wrapperDiv.appendChild(scrollUpButton);
        wrapperDiv.appendChild(scrollDownButton);
        wrapperDiv.appendChild(instructionDiv);
        pageCont.appendChild(wrapperDiv);
        
        logMsg('Doorcam loaded with scrolling controls');
      } else if (page === 'Home status') {
        // Similar setup for Home status
        if (cursorVisible && highlightBorder) {
          cursorVisible = false;
          highlightBorder.style.display = 'none';
        }
        
        pageTitle.style.display = 'none';
        playlistContainer.style.display = 'none';
        artCont.style.opacity = 0;
        pageCont.style.opacity = 1;
        pageCont.style.pointerEvents = 'auto';
        
        pageCont.innerHTML = '';
        
        // Create wrapper div for iframe and controls
        const wrapperDiv = document.createElement('div');
        wrapperDiv.style.width = '100%';
        wrapperDiv.style.height = '100%';
        wrapperDiv.style.position = 'relative';
        
        // Add scrolling instruction
        const instructionDiv = document.createElement('div');
        instructionDiv.style.position = 'absolute';
        instructionDiv.style.bottom = '20px';
        instructionDiv.style.left = '50%';
        instructionDiv.style.transform = 'translateX(-50%)';
        instructionDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
        instructionDiv.style.color = 'white';
        instructionDiv.style.padding = '10px';
        instructionDiv.style.borderRadius = '5px';
        instructionDiv.style.zIndex = '1000';
        instructionDiv.textContent = 'Use wheel to scroll up/down';
        instructionDiv.style.opacity = '1';
        instructionDiv.style.transition = 'opacity 0.5s';
        
        // Fade out instruction after 3 seconds
        setTimeout(() => {
          instructionDiv.style.opacity = '0';
        }, 3000);
        
        // Create a scrollable container
        const scrollContainer = document.createElement('div');
        scrollContainer.style.width = '100%';
        scrollContainer.style.height = '100%';
        scrollContainer.style.overflow = 'auto';
        scrollContainer.className = 'iframe-scroll-container';
        
        // Create new iframe or update existing one
        if (!haIframe) {
          haIframe = document.createElement('iframe');
          haIframe.src = 'http://homeassistant.local:8123/dashboard-basement/basement';
          haIframe.style.width = '100%';
          haIframe.style.height = '200%'; // Make taller to allow scrolling
          haIframe.style.border = 'none';
          haIframe.style.pointerEvents = 'none'; // Prevent direct interaction with iframe
        } else {
          // Make sure iframe has the correct src
          if (haIframe.src !== 'http://homeassistant.local:8123/dashboard-basement/basement') {
            haIframe.src = 'http://homeassistant.local:8123/dashboard-basement/basement';
          }
          haIframe.style.pointerEvents = 'none'; // Ensure pointer events are disabled
        }
        
        // Scroll buttons
        const scrollUpButton = document.createElement('button');
        scrollUpButton.textContent = '▲';
        scrollUpButton.style.position = 'absolute';
        scrollUpButton.style.right = '20px';
        scrollUpButton.style.top = '20px';
        scrollUpButton.style.zIndex = '1000';
        scrollUpButton.style.padding = '10px 15px';
        scrollUpButton.style.backgroundColor = 'rgba(0,0,0,0.5)';
        scrollUpButton.style.color = 'white';
        scrollUpButton.style.border = 'none';
        scrollUpButton.style.borderRadius = '5px';
        scrollUpButton.style.cursor = 'pointer';
        
        const scrollDownButton = document.createElement('button');
        scrollDownButton.textContent = '▼';
        scrollDownButton.style.position = 'absolute';
        scrollDownButton.style.right = '20px';
        scrollDownButton.style.top = '70px';
        scrollDownButton.style.zIndex = '1000';
        scrollDownButton.style.padding = '10px 15px';
        scrollDownButton.style.backgroundColor = 'rgba(0,0,0,0.5)';
        scrollDownButton.style.color = 'white';
        scrollDownButton.style.border = 'none';
        scrollDownButton.style.borderRadius = '5px';
        scrollDownButton.style.cursor = 'pointer';
        
        // Add click handlers
        scrollUpButton.addEventListener('click', () => {
          scrollContainer.scrollTop -= 100;
        });
        
        scrollDownButton.addEventListener('click', () => {
          scrollContainer.scrollTop += 100;
        });
        
        // Append elements
        scrollContainer.appendChild(haIframe);
        wrapperDiv.appendChild(scrollContainer);
        wrapperDiv.appendChild(scrollUpButton);
        wrapperDiv.appendChild(scrollDownButton);
        wrapperDiv.appendChild(instructionDiv);
        pageCont.appendChild(wrapperDiv);
        
        logMsg('Home status loaded with scrolling controls');
      } else {
        pageTitle.style.display = 'block';
        playlistContainer.style.display = 'none';
        fadeToPage(page);
      }
    }
    activate(0);

    // Add click handlers to navigation items
    navItems.forEach((item, index) => {
      item.addEventListener('click', () => {
        activate(index);
      });
    });

    // laser event: show only bottom 25%
    function onLaser(pos){
      if(pos>70 && pos <102) nav.classList.remove('hidden'); else nav.classList.add('hidden');
      // leverage ×4 inverted
      let eff = (100-pos)*4; if(eff>100) eff=100;
      const idx = Math.round(eff*(navItems.length-1)/100);
      
      // If panel is shown and Home status is selected, ensure content is loaded
      if(pos>70 && pos <102 && idx === navItems.length-1) { // Home status is the last item
        // Make sure Home status page is shown properly
        if (pageCont.innerHTML === '' || !pageCont.querySelector('iframe')) {
          // Force Home status content to load
          logMsg('Ensuring Home status content is loaded');
          activate(navItems.length-1);
        }
      } else {
        activate(idx);
      }
    }

    // Prev/Next track
    async function prevTrack(){ await fetch(`${HA_URL}/api/services/media_player/media_previous_track`,{method:'POST',headers:{'Authorization':'Bearer '+HA_TOKEN,'Content-Type':'application/json'},body:JSON.stringify({entity_id:ENTITY})}); fetchMedia(); }
    async function nextTrack(){ await fetch(`${HA_URL}/api/services/media_player/media_next_track`,{method:'POST',headers:{'Authorization':'Bearer '+HA_TOKEN,'Content-Type':'application/json'},body:JSON.stringify({entity_id:ENTITY})}); fetchMedia(); }
    async function onGo(){ await fetch(`${HA_URL}/api/services/media_player/media_play_pause`,{method:'POST',headers:{'Authorization':'Bearer '+HA_TOKEN,'Content-Type':'application/json'},body:JSON.stringify({entity_id:ENTITY})}); fetchMedia(); }

    function fadeToPage(page){ pageTitle.textContent=page; pageCont.style.pointerEvents='auto'; artCont.style.opacity=0; pageCont.style.opacity=1; }
    function fadeToArtwork(){ pageCont.style.opacity=0; pageCont.style.pointerEvents='none'; artCont.style.opacity=1; }

    // Populate playlist with real names
    const realPlaylistNames = [
      'Chill Vibes',
      'Workout Mix',
      'Top Hits',
      'Jazz Classics',
      'Indie Essentials',
      'Party Anthems',
      'Relaxing Piano',
      'Rock Legends',
      'Country Roads',
      'Hip Hop Beats',
      'Classical Moods',
      'Reggae Rhythms',
      'Electronic Dance',
      'Soulful Sounds',
      'Acoustic Favorites',
      'Latin Grooves',
      'Blues Masters',
      'Pop Classics',
      'Folk Tales',
      'Ambient Atmospheres'
    ];

    realPlaylistNames.forEach(name => {
      const li = document.createElement('li');
      li.textContent = name;
      playlist.appendChild(li);
    });

    const playlistItems = [...playlist.querySelectorAll('li')];

    // Function to activate Home Assistant search
    function activateHaSearch() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Find search icon/button and click it
        const searchIcon = haIframe.contentDocument.querySelector('ha-icon-button[aria-label*="search"i], ha-icon-button[data-testid="search-button"], ha-icon[icon="mdi:magnify"]').closest('button, ha-icon-button');
        
        if (searchIcon) {
          searchIcon.click();
          haInterfaceState = 'search-pending';
          logMsg('Search activated');
          
          // Wait for search input to appear and focus it
          setTimeout(() => {
            const searchInput = haIframe.contentDocument.querySelector('input[aria-label*="search"i], input[placeholder*="search"i]');
            if (searchInput) {
              searchInput.focus();
              logMsg('Ready to search. Type and press Go');
            }
          }, 500);
        } else {
          logMsg('Search button not found');
        }
      } catch (e) {
        logMsg('Error activating search: ' + e.message);
      }
    }

    // Function to execute search (submit the search)
    function executeHaSearch() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Find search input
        const searchInput = haIframe.contentDocument.querySelector('input[aria-label*="search"i], input[placeholder*="search"i]');
        
        if (searchInput) {
          // Simulate pressing Enter to submit the search
          const enterEvent = new KeyboardEvent('keydown', {
            key: 'Enter',
            code: 'Enter',
            keyCode: 13,
            which: 13,
            bubbles: true
          });
          
          searchInput.dispatchEvent(enterEvent);
          haInterfaceState = 'search-results';
          logMsg('Search executed');
          
          // Wait for results to appear and scan them
          setTimeout(scanSearchResults, 1000);
        }
      } catch (e) {
        logMsg('Error executing search: ' + e.message);
      }
    }

    // Function to scan for search results
    function scanSearchResults() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Clear previous results
        searchResultElements = [];
        searchResultIndex = -1;
        
        // Find search result items
        const results = haIframe.contentDocument.querySelectorAll('.search-result, ha-card, [role="option"], [role="listitem"]');
        
        results.forEach(element => {
          // Check if element is visible
          const rect = element.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            searchResultElements.push({
              element: element,
              rect: rect
            });
          }
        });
        
        logMsg(`Found ${searchResultElements.length} search results`);
        
        // Select first result if any exist
        if (searchResultElements.length > 0) {
          searchResultIndex = 0;
          highlightSearchResult();
        }
      } catch (e) {
        logMsg('Error scanning search results: ' + e.message);
      }
    }

    // Function to navigate through search results
    function navigateSearchResults(direction) {
      if (searchResultElements.length === 0) return;
      
      if (direction === 'down') {
        searchResultIndex = (searchResultIndex + 1) % searchResultElements.length;
      } else {
        searchResultIndex = (searchResultIndex - 1 + searchResultElements.length) % searchResultElements.length;
      }
      
      highlightSearchResult();
    }

    // Function to highlight selected search result
    function highlightSearchResult() {
      if (searchResultIndex >= 0 && searchResultIndex < searchResultElements.length) {
        const item = searchResultElements[searchResultIndex];
        const rect = item.rect;
        
        // Create or show highlight border if not already visible
        if (!highlightBorder) initHighlightBorder();
        highlightBorder.style.display = 'block';
        
        // Convert iframe-relative position to document position
        const iframeRect = haIframe.getBoundingClientRect();
        const absoluteLeft = rect.left + iframeRect.left;
        const absoluteTop = rect.top + iframeRect.top;
        
        // Position highlight over the result
        highlightBorder.style.left = (absoluteLeft - 5) + 'px';
        highlightBorder.style.top = (absoluteTop - 5) + 'px';
        highlightBorder.style.width = (rect.width + 6) + 'px';
        highlightBorder.style.height = (rect.height + 6) + 'px';
        
        // Pulse effect for visibility
        highlightBorder.style.boxShadow = '0 0 20px 5px rgba(255, 255, 0, 0.9)';
        setTimeout(() => {
          highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
        }, 200);
        
        // Scroll into view if needed
        item.element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    // Function to click selected search result
    function clickSearchResult() {
      if (searchResultIndex >= 0 && searchResultIndex < searchResultElements.length) {
        try {
          const element = searchResultElements[searchResultIndex].element;
          element.click();
          
          // Visual feedback
          highlightBorder.style.boxShadow = '0 0 25px 8px rgba(255, 255, 0, 1)';
          setTimeout(() => {
            highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
            // Reset state after clicking
            haInterfaceState = 'normal';
            // Hide highlight after a moment
            setTimeout(() => {
              highlightBorder.style.display = 'none';
            }, 1000);
          }, 200);
          
          logMsg('Selected search result');
        } catch (e) {
          logMsg('Error clicking search result: ' + e.message);
        }
      }
    }

    // Handle Go button in Home Status page
    function onGo() {
      if (navItems[curIdx].textContent === 'Home status' || navItems[curIdx].textContent === 'Doorcam') {
        // Special handling for iframe pages
        // Use Go button to toggle the scroll buttons visibility
        const scrollButtons = pageCont.querySelectorAll('button');
        
        if (scrollButtons.length > 0) {
          const isVisible = scrollButtons[0].style.opacity !== '0';
          
          scrollButtons.forEach(button => {
            button.style.opacity = isVisible ? '0' : '1';
            button.style.pointerEvents = isVisible ? 'none' : 'auto';
          });
          
          // Show instruction about button visibility
          const instructionDiv = pageCont.querySelector('div[style*="bottom: 20px"]');
          if (instructionDiv) {
            instructionDiv.style.opacity = '1';
            instructionDiv.textContent = isVisible ? 'Scroll buttons hidden' : 'Scroll buttons visible';
            setTimeout(() => {
              instructionDiv.style.opacity = '0';
            }, 2000);
          }
          
          logMsg(isVisible ? 'Scroll buttons hidden' : 'Scroll buttons shown');
        } else {
          // Fall back to original behavior
          fetch(`${HA_URL}/api/services/media_player/media_play_pause`, {
            method: 'POST',
            headers: {'Authorization': 'Bearer ' + HA_TOKEN, 'Content-Type': 'application/json'},
            body: JSON.stringify({entity_id: ENTITY})
          }).then(() => fetchMedia());
        }
      } else {
        // Original behavior for other pages
        fetch(`${HA_URL}/api/services/media_player/media_play_pause`, {
          method: 'POST',
          headers: {'Authorization': 'Bearer ' + HA_TOKEN, 'Content-Type': 'application/json'},
          body: JSON.stringify({entity_id: ENTITY})
        }).then(() => fetchMedia());
      }
    }
  </script>
</body>
</html>
