<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BeoSound 5 Dashboard</title>
  <style>
    html, body { margin:0; padding:0; width:1024px; height:768px; overflow:hidden; background:#000; }
    #main-ui { display:flex; width:1024px; height:768px; }
    /* Sidebar */
    #nav { width:8%; min-width:80px; background:#1c1c1c; position:relative;
      transition: transform 0.3s ease;
    }
    #nav.hidden { transform: translateX(-100%); }
    #nav ul { list-style:none; margin:0; padding:20px 0; }
    #nav li { padding:12px; color:#fff; }
    #nav li.active { background:rgba(255,255,255,0.2); border-radius:4px; }
    #laser-pointer { position:absolute; width:4px; height:24px; background:cyan; left:0; transition: top 0.1s; }
    /* Content area */
    #content-area { flex:1; position:relative; overflow:hidden; }
    #artwork-container, #page-container {
      position:absolute; top:0; left:0; right:0; bottom:0;
      display:flex; align-items:center; justify-content:center;
      transition: opacity 0.5s ease;
    }
    #artwork-container { z-index:1; opacity:1; }
    #page-container { z-index:2; opacity:0; pointer-events:none; }
    #artwork { max-width:90%; max-height:90%; border-radius:8px; transition: opacity 0.6s ease; position:absolute; }
    #info-box { position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.7); color:#fff; padding:8px 16px; border-radius:8px;
      font-family:sans-serif; text-align:center; z-index:3;
    }
    #info-box #track-title { font-size:24px; margin-bottom:4px; }
    #info-box #track-album { font-size:16px; margin-bottom:2px; }
    #info-box #track-artist { font-size:14px; opacity:0.9; }
    /* Volume gauge: larger, more right */
    #vol-gauge { position:absolute; right:40px; top:50%; transform:translateY(-50%);
      width:200px; height:300px; z-index:3;
    }
    /* WS log */
    #ws-log { position:absolute; top:0; right:0; background:red; color:white;
      font-family:monospace; font-size:0.8em; padding:4px; width:300px; height:60px;
      overflow:hidden; z-index:10;
    }
    #playlist-container { 
      display: none; 
      color: white; 
      font-family: sans-serif; 
      text-align: center; 
      padding: 20px; 
    }
    #playlist { 
      list-style-type: none; 
      padding: 0; 
      margin: 0; 
      height: 100%; 
      overflow-y: auto; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      transform: perspective(500px) rotateY(-15deg); 
    }
    #playlist li { 
      font-size: 16px; 
      color: white; 
      transition: transform 0.3s ease, font-size 0.3s ease, color 0.3s ease; 
    }
    #playlist li.selected { 
      font-size: 24px; 
      color: cyan; 
    }
  </style>
</head>
<body>
  <div id="main-ui">
    <nav id="nav">
      <div id="laser-pointer"></div>
      <ul>
        <li>Playing now</li>
        <li>Playlists</li>
	      <li>Scenes</li>
        <li>Security</li>
        <li>Control</li>
        <li>Settings</li>
        <li>Home status</li>
      </ul>
    </nav>
    <div id="content-area">
      <div id="artwork-container">
        <img id="artwork" src="" alt="Art" />
        <div id="info-box">
          <div id="track-title">—</div>
          <div id="track-album">—</div>
          <div id="track-artist">—</div>
        </div>
      </div>
      <div id="page-container">
        <span id="page-title" style="color:white; font-size:48px;"></span>
        <div id="playlist-container">
          <ul id="playlist">
            <!-- Playlist items will be dynamically populated -->
          </ul>
        </div>
      </div>
      <canvas id="vol-gauge" width="200" height="300"></canvas>
      <div id="ws-log"></div>
    </div>
  </div>

  <script>
    // Elements
    const nav = document.getElementById('nav');
    const navItems = [...nav.querySelectorAll('li')];
    const pointer = document.getElementById('laser-pointer');
    const artCont = document.getElementById('artwork-container');
    const pageCont= document.getElementById('page-container');
    const pageTitle= document.getElementById('page-title');
    const artwork = document.getElementById('artwork');
    const titleEl = document.getElementById('track-title');
    const albumEl = document.getElementById('track-album');
    const artistEl= document.getElementById('track-artist');
    const wsLog   = document.getElementById('ws-log');
    const vg      = document.getElementById('vol-gauge');
    const ctx     = vg.getContext('2d');
    const playlistContainer = document.getElementById('playlist-container');
    const playlist = document.getElementById('playlist');

    // Create a cached Home Assistant iframe to reuse
    let haIframe = null;
    
    // Virtual cursor for iframe navigation
    let virtualCursor = null;
    let cursorVisible = false;
    let cursorSpeed = 10; // Pixels to move per arrow key press
    let currentElements = [];
    let selectedElementIndex = -1;
    let highlightBorder = null; // Element for highlighting cards
    
    // Search and navigation state
    let haInterfaceState = 'normal'; // States: 'normal', 'search-pending', 'search-results'
    let searchResultElements = [];
    let searchResultIndex = -1;

    // Logging function
    const recent = [];
    function logMsg(m) { 
      recent.unshift(m); 
      if(recent.length > 3) recent.pop(); 
      wsLog.innerText = recent.join('\n'); 
    }

    // HA config
    const HA_URL = 'http://homeassistant.local:8123';
    const HA_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJjMDY0NDFjNDRjOWM0YTQ3ODk1OWVmMjcwYzY2MTU2ZiIsImlhdCI6MTc0NTI2ODYzNywiZXhwIjoyMDYwNjI4NjM3fQ.ldZPYpESQgL_dQj026faUhBzqTgJBVH4oYSrXtWzfC0';
    const ENTITY = 'media_player.medierum';

    // Function to create and initialize the virtual cursor
    function initVirtualCursor() {
      // Create cursor element if it doesn't exist
      if (!virtualCursor) {
        virtualCursor = document.createElement('div');
        virtualCursor.style.position = 'absolute';
        virtualCursor.style.width = '20px';
        virtualCursor.style.height = '20px';
        virtualCursor.style.borderRadius = '50%';
        virtualCursor.style.backgroundColor = 'rgba(0, 255, 255, 0.5)';
        virtualCursor.style.border = '2px solid cyan';
        virtualCursor.style.zIndex = '10000';
        virtualCursor.style.pointerEvents = 'none'; // Don't interfere with real mouse events
        virtualCursor.style.transition = 'all 0.1s ease';
        virtualCursor.style.display = 'none';
        document.body.appendChild(virtualCursor);
      }
    }

    // Function to toggle cursor visibility
    function toggleVirtualCursor() {
      cursorVisible = !cursorVisible;
      virtualCursor.style.display = cursorVisible ? 'block' : 'none';
      
      // Position cursor in the middle of the iframe if becoming visible
      if (cursorVisible && haIframe) {
        const rect = haIframe.getBoundingClientRect();
        virtualCursor.style.left = (rect.left + rect.width / 2) + 'px';
        virtualCursor.style.top = (rect.top + rect.height / 2) + 'px';
        scanElementsInIframe();
      }
    }

    // Function to move the cursor
    function moveCursor(direction) {
      if (!cursorVisible || !virtualCursor) return;
      
      const rect = virtualCursor.getBoundingClientRect();
      let left = rect.left;
      let top = rect.top;
      
      switch (direction) {
        case 'up': top -= cursorSpeed; break;
        case 'down': top += cursorSpeed; break;
        case 'left': left -= cursorSpeed; break;
        case 'right': left += cursorSpeed; break;
      }
      
      // Keep cursor within iframe bounds
      const iframeRect = haIframe.getBoundingClientRect();
      left = Math.max(iframeRect.left, Math.min(left, iframeRect.right - rect.width));
      top = Math.max(iframeRect.top, Math.min(top, iframeRect.bottom - rect.height));
      
      virtualCursor.style.left = left + 'px';
      virtualCursor.style.top = top + 'px';
    }

    // Function to scan for clickable elements in the iframe
    function scanElementsInIframe() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Clear previous elements
        currentElements = [];
        selectedElementIndex = -1;
        
        // Find all potentially interactive elements
        const interactiveSelectors = 'a, button, input, select, [role="button"], [tabindex]';
        const elements = haIframe.contentDocument.querySelectorAll(interactiveSelectors);
        
        elements.forEach(element => {
          // Check if element is visible
          const rect = element.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            currentElements.push({
              element: element,
              rect: rect
            });
          }
        });
        
        logMsg(`Found ${currentElements.length} interactive elements`);
      } catch (e) {
        logMsg('Error scanning iframe: ' + e.message);
      }
    }

    // Function to highlight the next or previous element
    function navigateElements(direction) {
      if (!cursorVisible || currentElements.length === 0) return;
      
      if (direction === 'next') {
        selectedElementIndex = (selectedElementIndex + 1) % currentElements.length;
      } else {
        selectedElementIndex = (selectedElementIndex - 1 + currentElements.length) % currentElements.length;
      }
      
      highlightSelectedElement();
    }

    // Function to highlight the selected element
    function highlightSelectedElement() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        const item = currentElements[selectedElementIndex];
        const rect = item.rect;
        
        // Position cursor over the element
        virtualCursor.style.left = (rect.left + rect.width / 2) + 'px';
        virtualCursor.style.top = (rect.top + rect.height / 2) + 'px';
        
        // Highlight effect
        virtualCursor.style.transform = 'scale(1.5)';
        setTimeout(() => {
          virtualCursor.style.transform = 'scale(1)';
        }, 200);
      }
    }

    // Function to "click" the currently selected element
    function clickSelectedElement() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        try {
          const element = currentElements[selectedElementIndex].element;
          element.click();
          
          // Visual feedback
          virtualCursor.style.backgroundColor = 'rgba(255, 255, 0, 0.8)';
          setTimeout(() => {
            virtualCursor.style.backgroundColor = 'rgba(0, 255, 255, 0.5)';
            // Rescan elements after click, as the DOM might have changed
            setTimeout(scanElementsInIframe, 500);
          }, 200);
          
          logMsg('Clicked element: ' + element.tagName);
        } catch (e) {
          logMsg('Error clicking: ' + e.message);
        }
      }
    }

    // Setup keyboard control for the virtual cursor
    document.addEventListener('keydown', (e) => {
      // Only handle keys when on Home status page
      if (navItems[curIdx].textContent !== 'Home status') return;
      
      switch (e.key) {
        case 'Tab':
          if (!cursorVisible) {
            toggleVirtualCursor();
          }
          navigateElements(e.shiftKey ? 'prev' : 'next');
          e.preventDefault();
          break;
        case 'Enter':
        case ' ': // Space
          if (cursorVisible) {
            clickSelectedElement();
            e.preventDefault();
          }
          break;
        case 'Escape':
          if (cursorVisible) {
            toggleVirtualCursor();
            e.preventDefault();
          }
          break;
        case 'ArrowUp':
          if (cursorVisible) {
            moveCursor('up');
            e.preventDefault();
          }
          break;
        case 'ArrowDown':
          if (cursorVisible) {
            moveCursor('down');
            e.preventDefault();
          }
          break;
        case 'ArrowLeft':
          if (cursorVisible) {
            moveCursor('left');
            e.preventDefault();
          }
          break;
        case 'ArrowRight':
          if (cursorVisible) {
            moveCursor('right');
            e.preventDefault();
          }
          break;
      }
    });

    // Function to create highlight border for cards
    function initHighlightBorder() {
      if (!highlightBorder) {
        highlightBorder = document.createElement('div');
        highlightBorder.style.position = 'absolute';
        highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
        highlightBorder.style.borderRadius = '4px';
        highlightBorder.style.zIndex = '10000';
        highlightBorder.style.pointerEvents = 'none';
        highlightBorder.style.transition = 'all 0.2s ease';
        highlightBorder.style.display = 'none';
        document.body.appendChild(highlightBorder);
      }
    }

    // Function to toggle card navigation mode
    function toggleCardNavigation() {
      if (!highlightBorder) initHighlightBorder();
      
      cursorVisible = !cursorVisible;
      highlightBorder.style.display = cursorVisible ? 'block' : 'none';
      
      if (cursorVisible) {
        scanCardsInIframe();
        if (currentElements.length > 0) {
          selectedElementIndex = 0;
          highlightSelectedCard();
        }
      }
    }

    // Function to scan for cards in the iframe
    function scanCardsInIframe() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Clear previous elements
        currentElements = [];
        selectedElementIndex = -1;
        
        // Find all card elements in Home Assistant
        const cardElements = haIframe.contentDocument.querySelectorAll('hui-card, ha-card');
        
        cardElements.forEach(element => {
          // Check if element is visible
          const rect = element.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            currentElements.push({
              element: element,
              rect: rect
            });
          }
        });
        
        logMsg(`Found ${currentElements.length} cards`);
      } catch (e) {
        logMsg('Error scanning iframe: ' + e.message);
      }
    }

    // Function to navigate between cards
    function navigateCards(direction) {
      if (!cursorVisible || currentElements.length === 0) return;
      
      if (direction === 'right') {
        selectedElementIndex = (selectedElementIndex + 1) % currentElements.length;
      } else {
        selectedElementIndex = (selectedElementIndex - 1 + currentElements.length) % currentElements.length;
      }
      
      highlightSelectedCard();
    }

    // Function to highlight the selected card
    function highlightSelectedCard() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        const item = currentElements[selectedElementIndex];
        const rect = item.rect;
        
        // Convert iframe-relative position to document position
        const iframeRect = haIframe.getBoundingClientRect();
        const absoluteLeft = rect.left + iframeRect.left;
        const absoluteTop = rect.top + iframeRect.top;
        
        // Position highlight over the card with a slight expansion
        highlightBorder.style.left = (absoluteLeft - 5) + 'px';
        highlightBorder.style.top = (absoluteTop - 5) + 'px';
        highlightBorder.style.width = (rect.width + 6) + 'px';
        highlightBorder.style.height = (rect.height + 6) + 'px';
        
        // Pulse effect for visibility
        highlightBorder.style.boxShadow = '0 0 20px 5px rgba(255, 255, 0, 0.9)';
        setTimeout(() => {
          highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
        }, 200);
        
        // Scroll into view if needed
        item.element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    // Function to click the currently selected card
    function clickSelectedCard() {
      if (selectedElementIndex >= 0 && selectedElementIndex < currentElements.length) {
        try {
          const element = currentElements[selectedElementIndex].element;
          element.click();
          
          // Visual feedback
          highlightBorder.style.boxShadow = '0 0 25px 8px rgba(255, 255, 0, 1)';
          setTimeout(() => {
            highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
            // Rescan cards after click, as the DOM might have changed
            setTimeout(scanCardsInIframe, 500);
          }, 200);
          
          logMsg('Clicked card: ' + element.tagName);
        } catch (e) {
          logMsg('Error clicking: ' + e.message);
        }
      }
    }

    // Setup keyboard control for card navigation
    document.addEventListener('keydown', (e) => {
      // Only handle keys when on Home status page
      if (navItems[curIdx].textContent !== 'Home status') return;
      
      switch (e.key) {
        case 'c': // 'c' key to toggle card navigation
          toggleCardNavigation();
          e.preventDefault();
          break;
        case 'Enter': // Enter to click
          if (cursorVisible) {
            clickSelectedCard();
            e.preventDefault();
          }
          break;
        case 'Escape': // Escape to exit
          if (cursorVisible) {
            toggleCardNavigation();
            e.preventDefault();
          }
          break;
        case 'ArrowLeft': // Left arrow for previous card
          if (cursorVisible) {
            navigateCards('left');
            e.preventDefault();
          }
          break;
        case 'ArrowRight': // Right arrow for next card
          if (cursorVisible) {
            navigateCards('right');
            e.preventDefault();
          }
          break;
      }
    });

    // WebSocket
    let ws;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 20;
    const INITIAL_RECONNECT_DELAY = 1000; // 1 second

    function connectWebSocket() {
      ws = new WebSocket('ws://localhost:8765');
      
      ws.onopen = () => {
        logMsg('WS open');
        reconnectAttempts = 0; // Reset attempts on successful connection
      };
      
      ws.onclose = () => {
        logMsg('WS close');
        attemptReconnect();
      };
      
      ws.onerror = e => {
        logMsg('WS err');
        attemptReconnect();
      };
      
      ws.onmessage = ev => {
        const {type,data} = JSON.parse(ev.data); logMsg(`${type}:${JSON.stringify(data)}`);
        if(type==='button'){
          if (navItems[curIdx].textContent === 'Home status') {
            if (haInterfaceState === 'search-results') {
              // For search results navigation
              if(data.button==='left') navigateSearchResults('up');
              else if(data.button==='right') navigateSearchResults('down');
              else if(data.button==='go') onGo();
            } else if (cursorVisible) {
              // For card navigation
              if(data.button==='left') navigateCards('left');
              else if(data.button==='right') navigateCards('right');
              else if(data.button==='go') onGo();
            } else {
              // Normal mode
              if(data.button==='go') onGo();
              else if(data.button==='left') prevTrack();
              else if(data.button==='right') nextTrack();
            }
          } else {
            // Original behavior for other pages
            if(data.button==='left') prevTrack();
            else if(data.button==='right') nextTrack();
            else if(data.button==='go') onGo();
          }
        }
        if(type==='laser') onLaser(data.position);
        if(type==='playback') fetchMedia();
        if(type==='volume') drawGauge(data.speed);
        if(type==='nav') {
          if (navItems[curIdx].textContent === 'Home status') {
            if (haInterfaceState === 'search-results') {
              // For search results navigation
              if (data.direction === 'clock') {
                navigateSearchResults('down');
              } else {
                navigateSearchResults('up');
              }
            } else if (cursorVisible) {
              // For card navigation
              if (data.direction === 'clock') {
                navigateCards('right');
              } else {
                navigateCards('left');
              }
            } else {
              handleNav(data);
            }
          } else {
            handleNav(data);
          }
        }
      };
    }

    function handleNav(data) {
      const { direction, speed } = data;
      let currentIndex = playlistItems.findIndex(item => item.classList.contains('selected'));
      if (currentIndex === -1) currentIndex = 0;

      if (direction === 'clock') {
        currentIndex = Math.min(currentIndex + 1, playlistItems.length - 1);
      } else {
        currentIndex = Math.max(currentIndex - 1, 0);
      }

      playlistItems.forEach((item, index) => {
        item.classList.toggle('selected', index === currentIndex);
        item.style.fontSize = index === currentIndex ? '24px' : '16px';
        item.style.color = index === currentIndex ? 'cyan' : 'white';
      });

      // Scroll to the selected item
      const selectedItem = playlistItems[currentIndex];
      selectedItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    function attemptReconnect() {
      if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        logMsg('Max reconnection attempts reached');
        return;
      }

      const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);
      reconnectAttempts++;
      
      logMsg(`Attempting to reconnect in ${delay/1000} seconds...`);
      
      setTimeout(() => {
        logMsg(`Reconnection attempt ${reconnectAttempts}`);
        connectWebSocket();
      }, delay);
    }

    // Initial connection
    connectWebSocket();

    // fetch media + volume
    async function fetchMedia(){
      try{
        const r=await fetch(`${HA_URL}/api/states/${ENTITY}`,{headers:{'Authorization':'Bearer '+HA_TOKEN}});
        const d=await r.json();
        const pic=HA_URL+d.attributes.entity_picture;
        const vol = Math.round((d.attributes.volume_level||0)*100);
        // update metadata
        titleEl.textContent=d.attributes.media_title||'—';
        albumEl.textContent=d.attributes.media_album_name||'—';
        artistEl.textContent=d.attributes.media_artist||'—';
        // update artwork with crossfade
        if(artwork.src !== pic) {
          artwork.style.opacity = 0;
          artwork.addEventListener('transitionend', function once() {
            artwork.removeEventListener('transitionend', once);
            artwork.src = pic;
            artwork.style.opacity = 1;
          });
        }
        // update gauge
        drawGauge(vol);
      } catch(e) { console.warn(e); }
    }
    fetchMedia(); setInterval(fetchMedia,5000);

    // nav activation
    let curIdx=0;
    function activate(i){ if(i<0)i=0; if(i>=navItems.length)i=navItems.length-1; curIdx=i;
      navItems.forEach((li,j)=>li.classList.toggle('active',j===i));
      const nr=nav.getBoundingClientRect(), ir=navItems[i].getBoundingClientRect();
      pointer.style.top=(ir.top-nr.top+4)+'px';
      
      // Handle page display based on selected item
      const page = navItems[curIdx].textContent;
      
      // Save iframe from being destroyed when navigating away from Home status
      if (pageCont.querySelector('iframe') && page !== 'Home status') {
        if (!haIframe) {
          haIframe = pageCont.querySelector('iframe');
        }
        pageCont.innerHTML = '';
        // Restore the pageTitle and playlist container elements
        if (!pageCont.contains(pageTitle)) {
          pageCont.appendChild(pageTitle);
        }
        if (!pageCont.contains(playlistContainer)) {
          pageCont.appendChild(playlistContainer);
        }
        
        // Hide navigation highlight when leaving Home status page
        if (cursorVisible && highlightBorder) {
          cursorVisible = false;
          highlightBorder.style.display = 'none';
        }
      }
      
      if (page === 'Playing now') {
        pageTitle.style.display = 'block';
        fadeToArtwork();
      } else if (page === 'Playlists') {
        pageTitle.style.display = 'none';
        playlistContainer.style.display = 'block';
        artCont.style.opacity = 0;
        pageCont.style.opacity = 1;
        pageCont.style.pointerEvents = 'auto';
        playlistItems.forEach((item, index) => {
          item.style.fontSize = '16px';
          item.style.color = 'white';
        });
      } else if (page === 'Home status') {
        pageTitle.style.display = 'none';
        playlistContainer.style.display = 'none';
        artCont.style.opacity = 0;
        pageCont.style.opacity = 1;
        pageCont.style.pointerEvents = 'auto';
        
        pageCont.innerHTML = '';
        
        // Use cached iframe if available, otherwise create a new one
        if (!haIframe) {
          haIframe = document.createElement('iframe');
          haIframe.src = 'http://homeassistant.local:8123/dashboard-basement/basement';
          haIframe.style.width = '100%';
          haIframe.style.height = '100%';
          haIframe.style.border = 'none';
          
          // Initialize card navigation after iframe loads
          haIframe.onload = () => {
            initHighlightBorder();
            logMsg('Iframe loaded. Press c to activate card navigation.');
          };
        } else {
          // If iframe already exists and is being reused
          initHighlightBorder();
          logMsg('Press c to activate card navigation.');
        }
        
        pageCont.appendChild(haIframe);
      } else {
        pageTitle.style.display = 'block';
        playlistContainer.style.display = 'none';
        fadeToPage(page);
      }
    }
    activate(0);

    // Add click handlers to navigation items
    navItems.forEach((item, index) => {
      item.addEventListener('click', () => {
        activate(index);
      });
    });

    // laser event: show only bottom 25%
    function onLaser(pos){
      if(pos>70 && pos <102) nav.classList.remove('hidden'); else nav.classList.add('hidden');
      // leverage ×4 inverted
      let eff = (100-pos)*4; if(eff>100) eff=100;
      const idx = Math.round(eff*(navItems.length-1)/100);
      activate(idx);
    }

    // Prev/Next track
    async function prevTrack(){ await fetch(`${HA_URL}/api/services/media_player/media_previous_track`,{method:'POST',headers:{'Authorization':'Bearer '+HA_TOKEN,'Content-Type':'application/json'},body:JSON.stringify({entity_id:ENTITY})}); fetchMedia(); }
    async function nextTrack(){ await fetch(`${HA_URL}/api/services/media_player/media_next_track`,{method:'POST',headers:{'Authorization':'Bearer '+HA_TOKEN,'Content-Type':'application/json'},body:JSON.stringify({entity_id:ENTITY})}); fetchMedia(); }
    async function onGo(){ await fetch(`${HA_URL}/api/services/media_player/media_play_pause`,{method:'POST',headers:{'Authorization':'Bearer '+HA_TOKEN,'Content-Type':'application/json'},body:JSON.stringify({entity_id:ENTITY})}); fetchMedia(); }

    function fadeToPage(page){ pageTitle.textContent=page; pageCont.style.pointerEvents='auto'; artCont.style.opacity=0; pageCont.style.opacity=1; }
    function fadeToArtwork(){ pageCont.style.opacity=0; pageCont.style.pointerEvents='none'; artCont.style.opacity=1; }

    // volume gauge
    function drawGauge(val){ const pct=val/100; ctx.clearRect(0,0,vg.width,vg.height); ctx.lineWidth=20; ctx.strokeStyle='#333'; ctx.beginPath(); ctx.arc(vg.width,vg.height/2,vg.width-10,Math.PI/2,3*Math.PI/2); ctx.stroke(); ctx.strokeStyle='#4fc3f7'; ctx.beginPath(); ctx.arc(vg.width,vg.height/2,vg.width-10,Math.PI/2,Math.PI/2+Math.PI*pct,false); ctx.stroke(); }

    // Populate playlist with real names
    const realPlaylistNames = [
      'Chill Vibes',
      'Workout Mix',
      'Top Hits',
      'Jazz Classics',
      'Indie Essentials',
      'Party Anthems',
      'Relaxing Piano',
      'Rock Legends',
      'Country Roads',
      'Hip Hop Beats',
      'Classical Moods',
      'Reggae Rhythms',
      'Electronic Dance',
      'Soulful Sounds',
      'Acoustic Favorites',
      'Latin Grooves',
      'Blues Masters',
      'Pop Classics',
      'Folk Tales',
      'Ambient Atmospheres'
    ];

    realPlaylistNames.forEach(name => {
      const li = document.createElement('li');
      li.textContent = name;
      playlist.appendChild(li);
    });

    const playlistItems = [...playlist.querySelectorAll('li')];

    // Function to activate Home Assistant search
    function activateHaSearch() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Find search icon/button and click it
        const searchIcon = haIframe.contentDocument.querySelector('ha-icon-button[aria-label*="search"i], ha-icon-button[data-testid="search-button"], ha-icon[icon="mdi:magnify"]').closest('button, ha-icon-button');
        
        if (searchIcon) {
          searchIcon.click();
          haInterfaceState = 'search-pending';
          logMsg('Search activated');
          
          // Wait for search input to appear and focus it
          setTimeout(() => {
            const searchInput = haIframe.contentDocument.querySelector('input[aria-label*="search"i], input[placeholder*="search"i]');
            if (searchInput) {
              searchInput.focus();
              logMsg('Ready to search. Type and press Go');
            }
          }, 500);
        } else {
          logMsg('Search button not found');
        }
      } catch (e) {
        logMsg('Error activating search: ' + e.message);
      }
    }

    // Function to execute search (submit the search)
    function executeHaSearch() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Find search input
        const searchInput = haIframe.contentDocument.querySelector('input[aria-label*="search"i], input[placeholder*="search"i]');
        
        if (searchInput) {
          // Simulate pressing Enter to submit the search
          const enterEvent = new KeyboardEvent('keydown', {
            key: 'Enter',
            code: 'Enter',
            keyCode: 13,
            which: 13,
            bubbles: true
          });
          
          searchInput.dispatchEvent(enterEvent);
          haInterfaceState = 'search-results';
          logMsg('Search executed');
          
          // Wait for results to appear and scan them
          setTimeout(scanSearchResults, 1000);
        }
      } catch (e) {
        logMsg('Error executing search: ' + e.message);
      }
    }

    // Function to scan for search results
    function scanSearchResults() {
      if (!haIframe || !haIframe.contentDocument) return;
      
      try {
        // Clear previous results
        searchResultElements = [];
        searchResultIndex = -1;
        
        // Find search result items
        const results = haIframe.contentDocument.querySelectorAll('.search-result, ha-card, [role="option"], [role="listitem"]');
        
        results.forEach(element => {
          // Check if element is visible
          const rect = element.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            searchResultElements.push({
              element: element,
              rect: rect
            });
          }
        });
        
        logMsg(`Found ${searchResultElements.length} search results`);
        
        // Select first result if any exist
        if (searchResultElements.length > 0) {
          searchResultIndex = 0;
          highlightSearchResult();
        }
      } catch (e) {
        logMsg('Error scanning search results: ' + e.message);
      }
    }

    // Function to navigate through search results
    function navigateSearchResults(direction) {
      if (searchResultElements.length === 0) return;
      
      if (direction === 'down') {
        searchResultIndex = (searchResultIndex + 1) % searchResultElements.length;
      } else {
        searchResultIndex = (searchResultIndex - 1 + searchResultElements.length) % searchResultElements.length;
      }
      
      highlightSearchResult();
    }

    // Function to highlight selected search result
    function highlightSearchResult() {
      if (searchResultIndex >= 0 && searchResultIndex < searchResultElements.length) {
        const item = searchResultElements[searchResultIndex];
        const rect = item.rect;
        
        // Create or show highlight border if not already visible
        if (!highlightBorder) initHighlightBorder();
        highlightBorder.style.display = 'block';
        
        // Convert iframe-relative position to document position
        const iframeRect = haIframe.getBoundingClientRect();
        const absoluteLeft = rect.left + iframeRect.left;
        const absoluteTop = rect.top + iframeRect.top;
        
        // Position highlight over the result
        highlightBorder.style.left = (absoluteLeft - 5) + 'px';
        highlightBorder.style.top = (absoluteTop - 5) + 'px';
        highlightBorder.style.width = (rect.width + 6) + 'px';
        highlightBorder.style.height = (rect.height + 6) + 'px';
        
        // Pulse effect for visibility
        highlightBorder.style.boxShadow = '0 0 20px 5px rgba(255, 255, 0, 0.9)';
        setTimeout(() => {
          highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
        }, 200);
        
        // Scroll into view if needed
        item.element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    // Function to click selected search result
    function clickSearchResult() {
      if (searchResultIndex >= 0 && searchResultIndex < searchResultElements.length) {
        try {
          const element = searchResultElements[searchResultIndex].element;
          element.click();
          
          // Visual feedback
          highlightBorder.style.boxShadow = '0 0 25px 8px rgba(255, 255, 0, 1)';
          setTimeout(() => {
            highlightBorder.style.boxShadow = '0 0 15px 5px rgba(255, 255, 0, 0.7)';
            // Reset state after clicking
            haInterfaceState = 'normal';
            // Hide highlight after a moment
            setTimeout(() => {
              highlightBorder.style.display = 'none';
            }, 1000);
          }, 200);
          
          logMsg('Selected search result');
        } catch (e) {
          logMsg('Error clicking search result: ' + e.message);
        }
      }
    }

    // Handle Go button in Home Status page - updated to include search functionality
    function onGo() {
      if (navItems[curIdx].textContent === 'Home status') {
        // Handle different states for the Go button in HA interface
        if (haInterfaceState === 'normal') {
          if (cursorVisible) {
            clickSelectedCard(); // If in card navigation mode
          } else {
            activateHaSearch(); // Activate search if in normal mode
          }
        } else if (haInterfaceState === 'search-pending') {
          executeHaSearch(); // Execute search if waiting for search input
        } else if (haInterfaceState === 'search-results') {
          clickSearchResult(); // Select result if navigating search results
        }
      } else {
        // Original behavior for other pages
        fetch(`${HA_URL}/api/services/media_player/media_play_pause`, {
          method: 'POST',
          headers: {'Authorization': 'Bearer ' + HA_TOKEN, 'Content-Type': 'application/json'},
          body: JSON.stringify({entity_id: ENTITY})
        }).then(() => fetchMedia());
      }
    }
  </script>
</body>
</html>
